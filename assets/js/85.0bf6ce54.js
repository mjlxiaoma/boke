(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{440:function(v,_,t){"use strict";t.r(_);var e=t(7),a=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"csr-客户端渲染"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#csr-客户端渲染"}},[v._v("#")]),v._v(" CSR 客户端渲染")]),v._v(" "),_("blockquote",[_("p",[_("code",[v._v("CSR")]),v._v(" 客户端渲染（Client Side Rendering）")])]),v._v(" "),_("p",[v._v("客户端渲染是指浏览器在请求页面 "),_("code",[v._v("URL")]),v._v(" 后，服务端直接返回一个空的静态 "),_("code",[v._v("HTML")]),v._v(" 文件，这个 HTML 文件需要再加载 "),_("code",[v._v("JavaScript")]),v._v(" 脚本和 "),_("code",[v._v("CSS")]),v._v(" 样式表，浏览器加载和执行这些文件去动态改变 "),_("code",[v._v("DOM")]),v._v(" 树的结构，使页面渲染成用户所需要的界面，这种动态渲染的方式就是客户端渲染 （CSR）")]),v._v(" "),_("h3",{attrs:{id:"优点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[v._v("#")]),v._v(" 优点")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("局部刷新")]),v._v("：无需每次都进行完整页面请求")]),v._v(" "),_("li",[_("strong",[v._v("懒加载")]),v._v("：首次加载时可以只加载可视区域内的数据")]),v._v(" "),_("li",[v._v("丰富的站点交互")]),v._v(" "),_("li",[v._v("减轻服务器压力")]),v._v(" "),_("li",[v._v("前后端分离")])]),v._v(" "),_("h3",{attrs:{id:"缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[v._v("#")]),v._v(" 缺点")]),v._v(" "),_("ul",[_("li",[v._v("不利于 SEO")]),v._v(" "),_("li",[_("strong",[v._v("首屏渲染慢")]),v._v("：需要等待 "),_("code",[v._v("JavaScript")]),v._v(" 脚本文件加载完毕后才开始渲染页面")])]),v._v(" "),_("p",[v._v("SEO")]),v._v(" "),_("p",[v._v("SEO（Search Engine Optimization）："),_("strong",[v._v("搜索引擎优化")]),v._v("，利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。目的是让其在行业内占据领先地位，获得品牌收益。")]),v._v(" "),_("h2",{attrs:{id:"ssr-服务端渲染"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ssr-服务端渲染"}},[v._v("#")]),v._v(" SSR 服务端渲染")]),v._v(" "),_("blockquote",[_("p",[_("code",[v._v("SSR")]),v._v(" 服务端渲染（Server Side Rendering）")])]),v._v(" "),_("p",[v._v("服务端渲染是指浏览器在请求页面 "),_("code",[v._v("URL")]),v._v(" 时，服务端将我们需要的 "),_("code",[v._v("HTML")]),v._v(" 文本组装好，并返回给浏览器，这个 "),_("code",[v._v("HTML")]),v._v(" 文本被浏览器解析之后，不需要经过 "),_("code",[v._v("JavaScript")]),v._v(" 脚本的下载过程，就能直接构建出我们所希望的 "),_("code",[v._v("DOM")]),v._v(" 树并展示到页面中。这个服务端组装 "),_("code",[v._v("HTML")]),v._v(" 的过程就叫做服务端渲染（SSR）")]),v._v(" "),_("h3",{attrs:{id:"优点-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优点-2"}},[v._v("#")]),v._v(" 优点")]),v._v(" "),_("ul",[_("li",[v._v("有利于 SEO")]),v._v(" "),_("li",[v._v("首屏渲染快")])]),v._v(" "),_("h3",{attrs:{id:"缺点-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缺点-2"}},[v._v("#")]),v._v(" 缺点")]),v._v(" "),_("ul",[_("li",[v._v("占用服务器资源")]),v._v(" "),_("li",[v._v("用户体验不好：新页面都需要在服务端重新渲染整个页面，不能局部渲染")]),v._v(" "),_("li",[v._v("模板维护成本高")])]),v._v(" "),_("h2",{attrs:{id:"同构渲染"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#同构渲染"}},[v._v("#")]),v._v(" 同构渲染")]),v._v(" "),_("p",[v._v("同构渲染是一种现代化服务端渲染方案，实际上是将 "),_("code",[v._v("CSR")]),v._v(" 客户端渲染和 "),_("code",[v._v("SSR")]),v._v(" 服务端渲染的优势结合起来实现互补；\n其流程是先在 "),_("code",[v._v("Node.js")]),v._v(" 中进行服务端渲染生成 "),_("code",[v._v("HTML")]),v._v("，然后通过客户端渲染接管页面交互")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("同构：是指同一套代码可以")]),v._v(" "),_("p",[v._v("同时运行在服务端和客户端")]),v._v(" "),_("ul",[_("li",[v._v("路由同构")]),v._v(" "),_("li",[v._v("数据同构")]),v._v(" "),_("li",[v._v("渲染同构")])])]),v._v(" "),_("li",[_("p",[v._v("脱水（"),_("code",[v._v("dehydrate")]),v._v("）：在服务端渲染直出 "),_("code",[v._v("HTML")]),v._v(" 前将预取的数据注入到 "),_("code",[v._v("window")]),v._v(" 中")])]),v._v(" "),_("li",[_("p",[v._v("注水（"),_("code",[v._v("hydrate")]),v._v("）：在客户端进行渲染前将 "),_("code",[v._v("window")]),v._v(" 上绑定的数据传入到对应组件中")])])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://liaoyio.github.io/notes/assets/page-rendering-isomorphism.1afe0a81.png",alt:"同构渲染流程"}})]),v._v(" "),_("p",[v._v("为什么需要数据的脱水和注水？")]),v._v(" "),_("p",[v._v("保证服务端和客户端端渲染的组件具有相同的 "),_("code",[v._v("props")]),v._v(" 和 "),_("code",[v._v("DOM")]),v._v(" 结构")]),v._v(" "),_("h3",{attrs:{id:"优点-3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优点-3"}},[v._v("#")]),v._v(" 优点")]),v._v(" "),_("ul",[_("li",[v._v("有利于 SEO")]),v._v(" "),_("li",[v._v("首屏渲染快")]),v._v(" "),_("li",[_("strong",[v._v("局部刷新")]),v._v("：无需每次都进行完整页面请求")])]),v._v(" "),_("h3",{attrs:{id:"缺点-3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缺点-3"}},[v._v("#")]),v._v(" 缺点")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("Node")]),v._v(" 服务的性能压力")]),v._v(" "),_("li",[v._v("服务端和浏览器环境的差异")])]),v._v(" "),_("h3",{attrs:{id:"开箱即用的-ssr-框架"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#开箱即用的-ssr-框架"}},[v._v("#")]),v._v(" 开箱即用的 SSR 框架")]),v._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"https://github.com/vercel/next.js",target:"_blank",rel:"noopener noreferrer"}},[v._v("Next.js"),_("OutboundLink")],1),v._v(" "),_("code",[v._v("React")]),v._v(" 应用开发框架")]),v._v(" "),_("li",[_("a",{attrs:{href:"https://github.com/nuxt/nuxt.js",target:"_blank",rel:"noopener noreferrer"}},[v._v("Nuxt.js"),_("OutboundLink")],1),v._v(" "),_("code",[v._v("Vue.js")]),v._v(" 通用应用框架")])]),v._v(" "),_("h2",{attrs:{id:"ssg-静态站点生成"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ssg-静态站点生成"}},[v._v("#")]),v._v(" SSG 静态站点生成")]),v._v(" "),_("blockquote",[_("p",[_("code",[v._v("SSG")]),v._v(" 静态网站生成（Static Site Generation）")])]),v._v(" "),_("p",[v._v("静态站点生成是指在构建时就会为每个页面生成包含内容的 "),_("code",[v._v("HTML")]),v._v(" 文件，当浏览器在请求页面 "),_("code",[v._v("URL")]),v._v(" 时，服务端直接返回 HTML 即可。")]),v._v(" "),_("h3",{attrs:{id:"优点-4"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优点-4"}},[v._v("#")]),v._v(" 优点")]),v._v(" "),_("ul",[_("li",[v._v("有利于 SEO")]),v._v(" "),_("li",[v._v("首屏渲染快")]),v._v(" "),_("li",[v._v("减轻服务器压力")])]),v._v(" "),_("h3",{attrs:{id:"缺点-4"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缺点-4"}},[v._v("#")]),v._v(" 缺点")]),v._v(" "),_("ul",[_("li",[v._v("每次更改内容时都需要重新构建和部署应用程序")]),v._v(" "),_("li",[v._v("无法生成用户相关内容")])]),v._v(" "),_("p",[v._v("SSG 应用场景")]),v._v(" "),_("p",[v._v("SSG 适合应用在页面内容在构建时就能确定的场景")]),v._v(" "),_("ul",[_("li",[v._v("静态官网")]),v._v(" "),_("li",[v._v("文档网站")])])])}),[],!1,null,null,null);_.default=a.exports}}]);