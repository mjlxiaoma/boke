(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{385:function(h,s,t){"use strict";t.r(s);var a=t(7),r=Object(a.a)({},(function(){var h=this,s=h._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":h.$parent.slotKey}},[s("h1",{attrs:{id:"history与hash"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#history与hash"}},[h._v("#")]),h._v(" history与hash")]),h._v(" "),s("h2",{attrs:{id:"history"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#history"}},[h._v("#")]),h._v(" history")]),h._v(" "),s("blockquote",[s("p",[h._v("history模式URL就要和后端进行一致，所以要改为history也需要后端的配合，否则会报错。\n所以hash模式在每次刷新页面时是直接更改“#”后的东西，history每次刷新会重新像后端请求整个网址，也就是重新请求服务器。如果后端没有及时响应，就会报错404！。history的好处是可以进行修改历史记录，并且不会立刻像后端发起请求。不过如果对于项目没有硬性标准要求，我们可以直接使用hash模式开发。")])]),h._v(" "),s("h2",{attrs:{id:"hash"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hash"}},[h._v("#")]),h._v(" hash")]),h._v(" "),s("blockquote",[s("ol",[s("li",[h._v("hash 就是指 url 后面的 # 号以及后面的字符，history没有带#，外观上比hash 模式好看些")]),h._v(" "),s("li",[h._v("原理的区别（原理）")]),h._v(" "),s("li",[h._v("hash 能兼容到IE8， history 只能兼容到 IE10")]),h._v(" "),s("li",[h._v("由于 hash 值变化不会导致浏览器向服务器发出请求，而且 hash 改变会触发 hashchange 事件（hashchange只能改变 # 后面的url片段）；虽然hash路径出现在URL中，但是不会出现在HTTP请求中，对后端完全没有影响，因此改变hash值不会重新加载页面，基本都是使用 hash 来实现前端路由的")])])]),h._v(" "),s("h2",{attrs:{id:"原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[h._v("#")]),h._v(" 原理")]),h._v(" "),s("blockquote",[s("p",[h._v("1.hash通过监听浏览器的 "),s("strong",[h._v("onhashchange()")]),h._v(" 事件变化，查找对应的路由规则")]),h._v(" "),s("p",[h._v("2.history原理： 利用H5的 history中新增的两个API "),s("strong",[h._v("pushState()")]),h._v(" 和 "),s("strong",[h._v("replaceState()")]),h._v(" 和一个事件"),s("strong",[h._v("onpopstate")]),h._v("监听URL变化")])]),h._v(" "),s("h2",{attrs:{id:"实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[h._v("#")]),h._v(" 实现")])])}),[],!1,null,null,null);s.default=r.exports}}]);